{
  "name": "simple-text-parser",
  "version": "0.1.2",
  "description": "A dead simple, customizable plain text parser.",
  "author": {
    "name": "Tyler Johnson",
    "email": "tyler@vintyge.com"
  },
  "main": "./app.js",
  "dependencies": {
    "underscore": "1.4.4"
  },
  "homepage": "https://github.com/appleifreak/simple-text-parser",
  "repository": {
    "type": "git",
    "url": "git://github.com/appleifreak/simple-text-parser.git"
  },
  "keywords": [
    "parse",
    "text",
    "plain",
    "regex",
    "string",
    "simple"
  ],
  "readme": "# Simple Text Parser\n\nThis is a dead simple text parser written in Javascript. It's based around strings and regular expressions so it's highly customizable, synchronous and relatively fast.\n\n## Install\n\nRequires Node.js and NPM. Simply install it into your package of choice.\n\n\tnpm install simple-text-parser --save\n\nThe `--save` will tell npm to add it to your `package.json`.\n\n## Usage\n\nThe STP package is a `Parser` class. Create a new object from it.\n\n```javascript\nvar Parser = require(\"simple-text-parser\"),\n    parser = new Parser();\n```\n\n## Examples\n\nSTP works by taking a plain text `String` and searching it for substrings and regular expressions. When a `match` is found, it is parsed out into a tree and replaced.\n\nLet's start by defining a parsing rule. Say we want to parse some text for hash tags (`#iamahashtag`) and replace it with some custom html:\n\n```javascript\n// Define a rule using a regular expression\nparser.addRule(/\\#[\\S]+/ig, function(tag) {\n\t// Return the tag minus the `#` and surrond with html tags\n\treturn \"<span class=\\\"tag\\\">\" + tag.substr(1) + \"</span>\";\n});\n```\n\nNow lets parse some text and output the resulting string:\n\n```javascript\nparser.parse(\"Some text #iamahashtag foo bar.\");\n```\n\nbecomes...\n\n```html\nSome text <span class=\"tag\">iamahashtag</span> foo bar.\n```\n\nOf course we can also parse some text into an `Object` tree for more custom handling and to retrieve the parsed data:\n\n```javascript\nparser.toTree(\"Some text #iamahashtag foo bar.\");\n```\n\noutputs...\n\n```javascript\n[ { type: 'text', text: 'Some text ' },\n  { type: 'text',\n    text: '<span class=\"tag\">iamahashtag</span>' },\n  { type: 'text', text: ' foo bar.' } ]\n```\n\nOf course a `type` of `text` on a tag isn't helpful when specifically trying to parse out tags. Let's modify our parsing rule to be more specfic:\n\n```javascript\n// Define a rule using a regular expression\nparser.addRule(/\\#[\\S]+/ig, function(tag) {\n\t// Get the tag minus the `#`\n\tvar clean_tag = tag.substr(1);\n\t\n\t// create the replacement text with surronding html tags\n\tvar text = \"<span class=\\\"tag\\\">\" + clean_tag + \"</span>\";\n\t\n\t// return an object describing this tag\n\treturn { type: \"tag\", text: text, tag: clean_tag };\n});\n```\n\nNow lets rerun `parse()` and `toTree()` on the original text. Notice that `parse()` outputs the same thing as before, but `toTree()` includes the custom meta data.\n\n```html\nSome text <span class=\"tag\">iamahashtag</span> foo bar.\n```\n\n```javascript\n[ { type: 'text', text: 'Some text ' },\n  { type: 'tag',\n    text: '<span class=\"tag\">iamahashtag</span>',\n    tag: 'iamahashtag' },\n  { type: 'text', text: ' foo bar.' } ]\n```\n\n## API Documentation\n\n### Class Methods\n\nThese methods can be called directly from the `Parser` class.\n\n#### Parser.registerPreset()\n\nRegister a new preset rule. This allows STP to be extended globally. Presets don't handle the replacing, only the matching. STP comes with three pre-included presets: `tag`, `url`, and `email`.\n\n```javascript\nParser.registerPreset(name, match);\n```\n\n* `name` (String) - The string id of the preset. Also the `type`.\n* `match` (String, RegExp, Function) - The search to perform. \n\n### Instance Methods\n\nThese methods can be called on objects returned from `new Parser()`.\n\n#### parser.addRule()\n\nAdd a parsing rule.\n\n```javascript\nparser.addRule(match, replace);\n```\n\n* `match` (String, RegExp, Function) - The search to perform. If a `String`, it is searched for exactly. If `RegExp`, a simple match is performed. If `Function`, it is called with a single argument: the full string passed to `parse()`.\n* `replace` (String, Function) - Replaces the match when found. When a `String`, it is replaces exactly. `Function`s are called with matched substring as the only argument.\n\n#### parser.addPreset()\n\nRegisters a preset rule within the instance.\n\n```javascript\nparser.addPreset(name, replace);\n```\n\n* `name` (String) - The string id of the preset. Also the `type`.\n* `replace` (String, Function) - Replaces the match when found.\n\n#### parser.toTree()\n\nReturns the parsed string as an array of objects describing each part. Every part includes at least a `type` and `text` key. `type` defaults to text. The `text` key is used to replaced the matched string.\n\n```javascript\nparser.toTree(str);\n```\n\n* `str` (String) - A plain text string to parse.\n\n#### parser.parse()\n\nReturns a parsed string with all rules replaced.\n\n```javascript\nparser.parse(str);\n```\n\n* `str` (String) - A plain text string to parse.",
  "readmeFilename": "README.md",
  "_id": "simple-text-parser@0.1.2",
  "dist": {
    "shasum": "35c5566ca6a586017ca5313c398e54b2009c39ff",
    "tarball": "http://registry.npmjs.org/simple-text-parser/-/simple-text-parser-0.1.2.tgz"
  },
  "_from": "simple-text-parser@",
  "_npmVersion": "1.2.18",
  "_npmUser": {
    "name": "mrgalaxy",
    "email": "tyler@vintyge.com"
  },
  "maintainers": [
    {
      "name": "mrgalaxy",
      "email": "tyler@vintyge.com"
    }
  ],
  "directories": {},
  "_shasum": "35c5566ca6a586017ca5313c398e54b2009c39ff",
  "_resolved": "https://registry.npmjs.org/simple-text-parser/-/simple-text-parser-0.1.2.tgz"
}
